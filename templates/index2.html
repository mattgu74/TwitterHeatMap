<!DOCTYPE HTML>
<html>
<head>
    <title>Tweetviz</title>
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.4.2.min.js"></script>
    <script type="text/javascript" src="http:////cdnjs.cloudflare.com/ajax/libs/socket.io/0.9.16/socket.io.min.js"></script>
    <script type="text/javascript" src="static/sigma.min.js"></script>
    <script type="text/javascript" src="static/plugins/sigma.layout.forceAtlas2.min.js"></script>
    <style>
    html,body { 
      height: 100%;
      margin: 0;
      padding: 0;
    }
    </style>
</head>
<body>
    <div id="info" style="position:absolute; z-index:100; top:0px; right:0px; width:200px; height: 100px; text-align: right; padding: 10px;">
      <span id="nodes"></span><strong> noeuds</strong><br/>
      <span id="edges"></span><strong> liens</strong><br/>
      <span id="tweets"></span><strong> tweets</strong><br/>
    </div>
    <div id="pub" style="position:absolute; z-index:100; top:0px; left:0px; width:160px; height: 600px;">
      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
      <!-- vertical -->
      <ins class="adsbygoogle"
           style="display:inline-block;width:160px;height:600px"
           data-ad-client="ca-pub-3348070071107733"
           data-ad-slot="1676732046"></ins>
      <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
    </div>
    <div id="vizArea" style="height: 100%; width:100%;"></div>
    <script type="text/javascript" charset="utf-8">
        var tweets_count = 0;
        var new_nodes = [];
        function nb_entities(msg) {
            return msg.entities.hashtags.length /*+ msg.entities.symbols.length + msg.entities.urls.length + msg.entities.user_mentions.length*/;
        }
        var run = true;
        var s = new sigma({
          renderer: {
            container: document.getElementById('vizArea')
          },
          type: 'canvas',
          settings: {
            autoRescale: false,
            mouseEnabled: true,
            touchEnabled: false,
            nodesPowRatio: 1,
            edgesPowRatio: 1,
            defaultEdgeColor: '#333',
            //defaultNodeColor: '#333',
            //edgeColor: 'default',
            //mode: 'canvas'
          }
        });
        var eId = 0;
        $(document).ready(function(){
            var socket = io.connect('http://' + document.domain + ':' + location.port + '/test');
            socket.on('tweet', function(msg) {
                tweets_count += 1;
                if(run && nb_entities(msg) > 0) {

                  try {
                    s.graph.addNode({
                      id: msg.user.id_str,
                      label: msg.user.name,
                      size: 2,
                      x: 10 + Math.random(),
                      y: 10 + Math.random(),
                      dX: 0,
                      dY: 0,
                      color: "#F00"
                    });
                    new_nodes.push(msg.user.id_str);
                  } catch(e) {}

                  msg.entities.hashtags.forEach(function(hashtag) {
                    try {
                      s.graph.addNode({
                        id: hashtag.text.toLowerCase(),
                        label: "#"+hashtag.text,
                        size: 2,
                        x: 50 + Math.random(),
                        y: 50 + Math.random(),
                        dX: 0,
                        dY: 0,
                        color: "#0F0"
                      });
                      new_nodes.push(hashtag.text.toLowerCase());
                    } catch(e) {}

                    s.graph.addEdge({
                      id: (++eId) + '',
                      source: msg.user.id_str,
                      target: hashtag.text.toLowerCase()
                    });

                    
                  });

                  msg.entities.user_mentions.forEach(function(user) {
                    try {
                      s.graph.addNode({
                        id: user.id_str,
                        label: user.name,
                        size: 2,
                        x: 10 + Math.random(),
                        y: 10 + Math.random(),
                        dX: 0,
                        dY: 0,
                        color: "#F00"
                      });
                      new_nodes.push(user.id_str);
                    } catch(e) {}

                    s.graph.addEdge({
                      id: (++eId) + '',
                      source: msg.user.id_str,
                      target: user.id_str
                    });

                    
                  });

                  s.refresh();
                  //$('#log').prepend('<br />@' + msg.user.screen_name + ': ' + msg.text);
                  //console.log(msg);
                }
            });
        });
        function forceAtlas() {
          s.startForceAtlas2({ 
              autoSettings: false,
              linLogMode: true
            });
        }

        function updateInfo() {
          nodes = s.graph.nodes().length;
          $("#nodes").html(nodes);
          $("#edges").html(s.graph.edges().length);
          $("#tweets").html(tweets_count);
          setTimeout(function() { updateInfo(); } , 500);
        }

        function unique(arr) {
            var u = {}, a = [];
            for(var i = 0, l = arr.length; i < l; ++i){
                if(!u.hasOwnProperty(arr[i])) {
                    a.push(arr[i]);
                    u[arr[i]] = 1;
                }
            }
            return a;
        }

        // fusion 
        function fusion(arr, items, nodes) {
          var new_val = nodes;
          for(var i=0; i<items.length; i++) {
            new_val = unique(new_val.concat(arr[items[i]]));
            arr.splice(arr.indexOf(items[i]), 1);
          }
          arr.push(new_val);
          return arr;
        }

        function debug(arr, msg) {
          console.log("debug", msg);
          for(var i=0; i<arr.length; i++) {
            console.log(arr[i]);
          }
          console.log("end debug", msg);
        }

        // nettoyage du graph
        // Retire les nodes qui sont trop peu connectÃ©s
        function cleanUp() {
          var g = [];
          var edges = s.graph.edges();
          for(var i=0; i<edges.length; i++) {
            var edge = edges[i];
            var presence_src = [];
            var presence_dest = [];
            for(var j=0; j<g.length; j++) {
              if(g[j].indexOf(edge.source) >= 0) {
                presence_src.push(j);
              }
              if(g[j].indexOf(edge.target) >= 0) {
                presence_dest.push(j);
              }
            }
            if((presence_dest.length + presence_src.length) == 0) {
              g.push([edge.source, edge.target]);
            } else {
              var to_concat = [];
              var presence = unique(presence_dest.concat(presence_src));
              g = fusion(g, presence, [edge.source, edge.target]);
            }
          }
          g.sort(function(a, b){
            return a.length- b.length; // ASC -> a - b; DESC -> b - a
          });
          var min = g[0].length;
          var max = g[g.length-1].length;
          var nodes = s.graph.nodes();
          var removed = 0, temp=0;
          //console.log(g, max, min);
          // On drop tout les nodes des graphs de taille < nodes/100
          for(var i=0;i<g.length;i++) {
            if(g[i].length < nodes.length/100) {
              for(var j=0; j<g[i].length; j++) {
                var n = s.graph.nodes(g[i][j])
                if(n) {
                  if(new_nodes.indexOf(n.id) < 0) {
                    try {
                      s.graph.dropNode(g[i][j]);
                      removed += 1;
                    } catch (e) {}
                  } else {
                    temp+=1;
                    new_nodes.splice(new_nodes.indexOf(n.id), 1);
                  }
                }
              }
            }
          }

          // Remove nodes alone if any
          for(var i=0; i<nodes.length; i++) {
            if(s.graph.degree(nodes[i].id) == 0) {
              s.graph.dropNode(nodes[i].id);
            }
          }

          setTimeout(function() { cleanUp(); } , 5000);

        }
        setTimeout(function() { updateInfo(); } , 500);
        setTimeout(function() { forceAtlas(); } , 5000);
        setTimeout(function() { cleanUp(); } , 5000);
    </script>
</body>
</html>
